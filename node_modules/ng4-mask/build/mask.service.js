import { Inject, Injectable } from '@angular/core';
import { config } from './config';
import { DOCUMENT } from '@angular/common';
var MaskService = /** @class */ (function () {
    function MaskService(// tslint:disable-next-line
        document, _config) {
        this.document = document;
        this._config = _config;
        this.maskExpression = '';
        // tslint:disable-next-line
        this.onChange = function (_) {
        };
        this.onTouch = function () {
        };
        this._shift = new Set();
        this.clearIfNotMatch = this._config.clearIfNotMatch;
        this.dropSpecialCharacters = this._config.dropSpecialCharacters;
        this.maskSpecialCharacters = this._config.specialCharacters;
        this.maskAvailablePatterns = this._config.patterns;
        this._regExpForRemove = new RegExp(this.maskSpecialCharacters
            .map(function (item) { return "\\" + item; })
            .join('|'), 'gi');
    }
    MaskService.prototype.applyMask = function (inputValue, maskExpression, position, cb) {
        if (position === void 0) { position = 0; }
        if (cb === void 0) { cb = function () {
        }; }
        if (inputValue === undefined || inputValue === null) {
            return '';
        }
        var cursor = 0;
        var result = '';
        var inputArray = inputValue.toString()
            .split('');
        // tslint:disable-next-line
        for (var i = 0, inputSymbol = inputArray[0]; i
            < inputArray.length; i++, inputSymbol = inputArray[i]) {
            if (result.length === maskExpression.length) {
                break;
            }
            if (this._checkSymbolMask(inputSymbol, maskExpression[cursor])) {
                result += inputSymbol;
                cursor++;
            }
            else if (this.maskSpecialCharacters.indexOf(maskExpression[cursor]) !== -1) {
                result += maskExpression[cursor];
                cursor++;
                this._shift.add(cursor);
                i--;
            }
            else if (this.maskSpecialCharacters.indexOf(inputSymbol) > -1
                && this.maskAvailablePatterns[maskExpression[cursor]]
                && this.maskAvailablePatterns[maskExpression[cursor]].optional) {
                cursor++;
                i--;
            }
        }
        if (result.length + 1 === maskExpression.length
            && this.maskSpecialCharacters.indexOf(maskExpression[maskExpression.length - 1]) !== -1) {
            result += maskExpression[maskExpression.length - 1];
        }
        var shift = 1;
        var newPosition = position + 1;
        while (this._shift.has(newPosition)) {
            shift++;
            newPosition++;
        }
        cb(this._shift.has(position) ? shift : 0);
        return result;
    };
    MaskService.prototype.applyValueChanges = function (element, position, cb) {
        if (position === void 0) { position = 0; }
        if (cb === void 0) { cb = function () {
        }; }
        var val = element.value;
        var maskedInput = this.applyMask(val, this.maskExpression, position, cb);
        element.value = maskedInput;
        if (this.dropSpecialCharacters === true) {
            this.onChange(this._removeMask(maskedInput));
        }
        else {
            this.onChange(maskedInput);
        }
        if (element !== this.document.activeElement) {
            this.clearIfNotMatchFn(element);
        }
    };
    MaskService.prototype.clearIfNotMatchFn = function (element) {
        if (this.clearIfNotMatch === true && this.maskExpression.length
            !== element.value.length) {
            element.value = '';
        }
    };
    MaskService.prototype._removeMask = function (value) {
        if (!value) {
            return value;
        }
        return value.replace(this._regExpForRemove, '');
    };
    MaskService.prototype._checkSymbolMask = function (inputSymbol, maskSymbol) {
        return inputSymbol
            === maskSymbol
            || this.maskAvailablePatterns[maskSymbol] && this.maskAvailablePatterns[maskSymbol].pattern
                && this.maskAvailablePatterns[maskSymbol].pattern.test(inputSymbol);
    };
    MaskService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    MaskService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
        { type: undefined, decorators: [{ type: Inject, args: [config,] },] },
    ]; };
    return MaskService;
}());
export { MaskService };
