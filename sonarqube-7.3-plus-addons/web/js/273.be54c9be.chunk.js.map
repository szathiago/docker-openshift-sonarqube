{"version":3,"sources":["webpack:///./node_modules/d3-hierarchy/src/hierarchy/count.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/index.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/each.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/eachAfter.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/eachBefore.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/sum.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/sort.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/path.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/ancestors.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/descendants.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/leaves.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/links.js","webpack:///./node_modules/d3-hierarchy/src/array.js","webpack:///./node_modules/d3-hierarchy/src/pack/enclose.js","webpack:///./node_modules/d3-hierarchy/src/accessors.js","webpack:///./node_modules/d3-hierarchy/src/constant.js","webpack:///./node_modules/d3-hierarchy/src/treemap/round.js","webpack:///./node_modules/d3-hierarchy/src/treemap/dice.js","webpack:///./node_modules/d3-hierarchy/src/tree.js","webpack:///./node_modules/d3-hierarchy/src/treemap/slice.js","webpack:///./node_modules/d3-hierarchy/src/treemap/squarify.js","webpack:///./node_modules/d3-hierarchy/src/treemap/index.js","webpack:///./node_modules/d3-hierarchy/src/treemap/resquarify.js","webpack:///./node_modules/lodash/_setToPairs.js","webpack:///./node_modules/lodash/_baseToPairs.js","webpack:///./node_modules/lodash/_createToPairs.js","webpack:///./node_modules/lodash/toPairs.js","webpack:///./node_modules/lodash/toInteger.js","webpack:///./node_modules/lodash/groupBy.js","webpack:///./node_modules/lodash/_baseFindIndex.js","webpack:///./node_modules/lodash/_createFind.js","webpack:///./node_modules/lodash/findIndex.js","webpack:///./node_modules/lodash/find.js"],"names":["count","node","sum","children","i","length","value","hierarchy","data","child","childs","n","root","Node","valued","nodes","defaultChildren","pop","Array","push","parent","depth","eachBefore","computeHeight","d","copyData","height","this","prototype","constructor","eachAfter","each","callback","current","next","reverse","sort","compare","path","end","start","ancestor","a","b","aNodes","ancestors","bNodes","c","leastCommonAncestor","k","splice","descendants","leaves","links","source","target","copy","slice","enclose","circles","p","e","array","t","m","Math","random","shuffle","call","B","enclosesWeak","encloseBasis","extendBasis","j","enclosesWeakAll","enclosesNot","encloseBasis2","encloseBasis3","Error","dr","r","dx","x","dy","y","x1","y1","r1","x2","y2","r2","x21","y21","r21","l","sqrt","x3","y3","r3","a2","a3","b2","b3","c2","c3","d1","d2","d3","ab","xa","xb","ya","yb","A","C","required","f","constantZero","constant","treemap_round","x0","round","y0","dice","TreeNode","_","z","s","Object","create","treemap_slice","phi","squarifyRatio","ratio","row","nodeValue","sumValue","minValue","maxValue","newRatio","minRatio","alpha","beta","rows","i0","i1","max","squarify","custom","src_treemap","tile","paddingStack","paddingInner","paddingTop","paddingRight","paddingBottom","paddingLeft","treemap","positionNode","arguments","size","padding","paddingOuter","resquarify","_squarify","module","exports","set","index","result","forEach","arrayMap","__webpack_require__","object","props","key","baseToPairs","getTag","mapToArray","setToPairs","mapTag","setTag","keysFunc","tag","toPairs","createToPairs","toFinite","remainder","baseAssignValue","createAggregator","hasOwnProperty","groupBy","predicate","fromIndex","fromRight","baseIteratee","isArrayLike","keys","findIndexFunc","collection","iterable","iteratee","undefined","baseFindIndex","toInteger","nativeMax","find","createFind"],"mappings":"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","file":"js/273.be54c9be.chunk.js","sourcesContent":["function count(node) {\n  var sum = 0,\n      children = node.children,\n      i = children && children.length;\n  if (!i) sum = 1;\n  else while (--i >= 0) sum += children[i].value;\n  node.value = sum;\n}\n\nexport default function() {\n  return this.eachAfter(count);\n}\n","import node_count from \"./count\";\nimport node_each from \"./each\";\nimport node_eachBefore from \"./eachBefore\";\nimport node_eachAfter from \"./eachAfter\";\nimport node_sum from \"./sum\";\nimport node_sort from \"./sort\";\nimport node_path from \"./path\";\nimport node_ancestors from \"./ancestors\";\nimport node_descendants from \"./descendants\";\nimport node_leaves from \"./leaves\";\nimport node_links from \"./links\";\n\nexport default function hierarchy(data, children) {\n  var root = new Node(data),\n      valued = +data.value && (root.value = data.value),\n      node,\n      nodes = [root],\n      child,\n      childs,\n      i,\n      n;\n\n  if (children == null) children = defaultChildren;\n\n  while (node = nodes.pop()) {\n    if (valued) node.value = +node.data.value;\n    if ((childs = children(node.data)) && (n = childs.length)) {\n      node.children = new Array(n);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new Node(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n\n  return root.eachBefore(computeHeight);\n}\n\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\n\nfunction defaultChildren(d) {\n  return d.children;\n}\n\nfunction copyData(node) {\n  node.data = node.data.data;\n}\n\nexport function computeHeight(node) {\n  var height = 0;\n  do node.height = height;\n  while ((node = node.parent) && (node.height < ++height));\n}\n\nexport function Node(data) {\n  this.data = data;\n  this.depth =\n  this.height = 0;\n  this.parent = null;\n}\n\nNode.prototype = hierarchy.prototype = {\n  constructor: Node,\n  count: node_count,\n  each: node_each,\n  eachAfter: node_eachAfter,\n  eachBefore: node_eachBefore,\n  sum: node_sum,\n  sort: node_sort,\n  path: node_path,\n  ancestors: node_ancestors,\n  descendants: node_descendants,\n  leaves: node_leaves,\n  links: node_links,\n  copy: node_copy\n};\n","export default function(callback) {\n  var node = this, current, next = [node], children, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      callback(node), children = node.children;\n      if (children) for (i = 0, n = children.length; i < n; ++i) {\n        next.push(children[i]);\n      }\n    }\n  } while (next.length);\n  return this;\n}\n","export default function(callback) {\n  var node = this, nodes = [node], next = [], children, i, n;\n  while (node = nodes.pop()) {\n    next.push(node), children = node.children;\n    if (children) for (i = 0, n = children.length; i < n; ++i) {\n      nodes.push(children[i]);\n    }\n  }\n  while (node = next.pop()) {\n    callback(node);\n  }\n  return this;\n}\n","export default function(callback) {\n  var node = this, nodes = [node], children, i;\n  while (node = nodes.pop()) {\n    callback(node), children = node.children;\n    if (children) for (i = children.length - 1; i >= 0; --i) {\n      nodes.push(children[i]);\n    }\n  }\n  return this;\n}\n","export default function(value) {\n  return this.eachAfter(function(node) {\n    var sum = +value(node.data) || 0,\n        children = node.children,\n        i = children && children.length;\n    while (--i >= 0) sum += children[i].value;\n    node.value = sum;\n  });\n}\n","export default function(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n}\n","export default function(end) {\n  var start = this,\n      ancestor = leastCommonAncestor(start, end),\n      nodes = [start];\n  while (start !== ancestor) {\n    start = start.parent;\n    nodes.push(start);\n  }\n  var k = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n}\n\nfunction leastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = a.ancestors(),\n      bNodes = b.ancestors(),\n      c = null;\n  a = aNodes.pop();\n  b = bNodes.pop();\n  while (a === b) {\n    c = a;\n    a = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c;\n}\n","export default function() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n}\n","export default function() {\n  var nodes = [];\n  this.each(function(node) {\n    nodes.push(node);\n  });\n  return nodes;\n}\n","export default function() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n}\n","export default function() {\n  var root = this, links = [];\n  root.each(function(node) {\n    if (node !== root) { // Don’t include the root’s parent, if any.\n      links.push({source: node.parent, target: node});\n    }\n  });\n  return links;\n}\n","export var slice = Array.prototype.slice;\n\nexport function shuffle(array) {\n  var m = array.length,\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n  }\n\n  return array;\n}\n","import {shuffle, slice} from \"../array\";\n\nexport default function(circles) {\n  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;\n\n  while (i < n) {\n    p = circles[i];\n    if (e && enclosesWeak(e, p)) ++i;\n    else e = encloseBasis(B = extendBasis(B, p)), i = 0;\n  }\n\n  return e;\n}\n\nfunction extendBasis(B, p) {\n  var i, j;\n\n  if (enclosesWeakAll(p, B)) return [p];\n\n  // If we get here then B must have at least one element.\n  for (i = 0; i < B.length; ++i) {\n    if (enclosesNot(p, B[i])\n        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {\n      return [B[i], p];\n    }\n  }\n\n  // If we get here then B must have at least two elements.\n  for (i = 0; i < B.length - 1; ++i) {\n    for (j = i + 1; j < B.length; ++j) {\n      if (enclosesNot(encloseBasis2(B[i], B[j]), p)\n          && enclosesNot(encloseBasis2(B[i], p), B[j])\n          && enclosesNot(encloseBasis2(B[j], p), B[i])\n          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {\n        return [B[i], B[j], p];\n      }\n    }\n  }\n\n  // If we get here then something is very wrong.\n  throw new Error;\n}\n\nfunction enclosesNot(a, b) {\n  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;\n  return dr < 0 || dr * dr < dx * dx + dy * dy;\n}\n\nfunction enclosesWeak(a, b) {\n  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\n\nfunction enclosesWeakAll(a, B) {\n  for (var i = 0; i < B.length; ++i) {\n    if (!enclosesWeak(a, B[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction encloseBasis(B) {\n  switch (B.length) {\n    case 1: return encloseBasis1(B[0]);\n    case 2: return encloseBasis2(B[0], B[1]);\n    case 3: return encloseBasis3(B[0], B[1], B[2]);\n  }\n}\n\nfunction encloseBasis1(a) {\n  return {\n    x: a.x,\n    y: a.y,\n    r: a.r\n  };\n}\n\nfunction encloseBasis2(a, b) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,\n      l = Math.sqrt(x21 * x21 + y21 * y21);\n  return {\n    x: (x1 + x2 + x21 / l * r21) / 2,\n    y: (y1 + y2 + y21 / l * r21) / 2,\n    r: (l + r1 + r2) / 2\n  };\n}\n\nfunction encloseBasis3(a, b, c) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x3 = c.x, y3 = c.y, r3 = c.r,\n      a2 = x1 - x2,\n      a3 = x1 - x3,\n      b2 = y1 - y2,\n      b3 = y1 - y3,\n      c2 = r2 - r1,\n      c3 = r3 - r1,\n      d1 = x1 * x1 + y1 * y1 - r1 * r1,\n      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,\n      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,\n      ab = a3 * b2 - a2 * b3,\n      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,\n      xb = (b3 * c2 - b2 * c3) / ab,\n      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,\n      yb = (a2 * c3 - a3 * c2) / ab,\n      A = xb * xb + yb * yb - 1,\n      B = 2 * (r1 + xa * xb + ya * yb),\n      C = xa * xa + ya * ya - r1 * r1,\n      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);\n  return {\n    x: x1 + xa + xb * r,\n    y: y1 + ya + yb * r,\n    r: r\n  };\n}\n","export function optional(f) {\n  return f == null ? null : required(f);\n}\n\nexport function required(f) {\n  if (typeof f !== \"function\") throw new Error;\n  return f;\n}\n","export function constantZero() {\n  return 0;\n}\n\nexport default function(x) {\n  return function() {\n    return x;\n  };\n}\n","export default function(node) {\n  node.x0 = Math.round(node.x0);\n  node.y0 = Math.round(node.y0);\n  node.x1 = Math.round(node.x1);\n  node.y1 = Math.round(node.y1);\n}\n","export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (x1 - x0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.y0 = y0, node.y1 = y1;\n    node.x0 = x0, node.x1 = x0 += node.value * k;\n  }\n}\n","import {Node} from \"./hierarchy/index\";\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nexport default function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.’s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n}\n","export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (y1 - y0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.x0 = x0, node.x1 = x1;\n    node.y0 = y0, node.y1 = y0 += node.value * k;\n  }\n}\n","import treemapDice from \"./dice\";\nimport treemapSlice from \"./slice\";\n\nexport var phi = (1 + Math.sqrt(5)) / 2;\n\nexport function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\nexport default (function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);\n","import roundNode from \"./round\";\nimport squarify from \"./squarify\";\nimport {required} from \"../accessors\";\nimport constant, {constantZero} from \"../constant\";\n\nexport default function() {\n  var tile = squarify,\n      round = false,\n      dx = 1,\n      dy = 1,\n      paddingStack = [0],\n      paddingInner = constantZero,\n      paddingTop = constantZero,\n      paddingRight = constantZero,\n      paddingBottom = constantZero,\n      paddingLeft = constantZero;\n\n  function treemap(root) {\n    root.x0 =\n    root.y0 = 0;\n    root.x1 = dx;\n    root.y1 = dy;\n    root.eachBefore(positionNode);\n    paddingStack = [0];\n    if (round) root.eachBefore(roundNode);\n    return root;\n  }\n\n  function positionNode(node) {\n    var p = paddingStack[node.depth],\n        x0 = node.x0 + p,\n        y0 = node.y0 + p,\n        x1 = node.x1 - p,\n        y1 = node.y1 - p;\n    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n    node.x0 = x0;\n    node.y0 = y0;\n    node.x1 = x1;\n    node.y1 = y1;\n    if (node.children) {\n      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n      x0 += paddingLeft(node) - p;\n      y0 += paddingTop(node) - p;\n      x1 -= paddingRight(node) - p;\n      y1 -= paddingBottom(node) - p;\n      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n      tile(node, x0, y0, x1, y1);\n    }\n  }\n\n  treemap.round = function(x) {\n    return arguments.length ? (round = !!x, treemap) : round;\n  };\n\n  treemap.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];\n  };\n\n  treemap.tile = function(x) {\n    return arguments.length ? (tile = required(x), treemap) : tile;\n  };\n\n  treemap.padding = function(x) {\n    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();\n  };\n\n  treemap.paddingInner = function(x) {\n    return arguments.length ? (paddingInner = typeof x === \"function\" ? x : constant(+x), treemap) : paddingInner;\n  };\n\n  treemap.paddingOuter = function(x) {\n    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();\n  };\n\n  treemap.paddingTop = function(x) {\n    return arguments.length ? (paddingTop = typeof x === \"function\" ? x : constant(+x), treemap) : paddingTop;\n  };\n\n  treemap.paddingRight = function(x) {\n    return arguments.length ? (paddingRight = typeof x === \"function\" ? x : constant(+x), treemap) : paddingRight;\n  };\n\n  treemap.paddingBottom = function(x) {\n    return arguments.length ? (paddingBottom = typeof x === \"function\" ? x : constant(+x), treemap) : paddingBottom;\n  };\n\n  treemap.paddingLeft = function(x) {\n    return arguments.length ? (paddingLeft = typeof x === \"function\" ? x : constant(+x), treemap) : paddingLeft;\n  };\n\n  return treemap;\n}\n","import treemapDice from \"./dice\";\nimport treemapSlice from \"./slice\";\nimport {phi, squarifyRatio} from \"./squarify\";\n\nexport default (function custom(ratio) {\n\n  function resquarify(parent, x0, y0, x1, y1) {\n    if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n      var rows,\n          row,\n          nodes,\n          i,\n          j = -1,\n          n,\n          m = rows.length,\n          value = parent.value;\n\n      while (++j < m) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;\n        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n      rows.ratio = ratio;\n    }\n  }\n\n  resquarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return resquarify;\n})(phi);\n","/**\n * Converts `set` to its value-value pairs.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the value-value pairs.\n */\nfunction setToPairs(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = [value, value];\n  });\n  return result;\n}\n\nmodule.exports = setToPairs;\n","var arrayMap = require('./_arrayMap');\n\n/**\n * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n * of key-value pairs for `object` corresponding to the property names of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the key-value pairs.\n */\nfunction baseToPairs(object, props) {\n  return arrayMap(props, function(key) {\n    return [key, object[key]];\n  });\n}\n\nmodule.exports = baseToPairs;\n","var baseToPairs = require('./_baseToPairs'),\n    getTag = require('./_getTag'),\n    mapToArray = require('./_mapToArray'),\n    setToPairs = require('./_setToPairs');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/**\n * Creates a `_.toPairs` or `_.toPairsIn` function.\n *\n * @private\n * @param {Function} keysFunc The function to get the keys of a given object.\n * @returns {Function} Returns the new pairs function.\n */\nfunction createToPairs(keysFunc) {\n  return function(object) {\n    var tag = getTag(object);\n    if (tag == mapTag) {\n      return mapToArray(object);\n    }\n    if (tag == setTag) {\n      return setToPairs(object);\n    }\n    return baseToPairs(object, keysFunc(object));\n  };\n}\n\nmodule.exports = createToPairs;\n","var createToPairs = require('./_createToPairs'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable string keyed-value pairs for `object`\n * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n * entries are returned.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @alias entries\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the key-value pairs.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.toPairs(new Foo);\n * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n */\nvar toPairs = createToPairs(keys);\n\nmodule.exports = toPairs;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var baseAssignValue = require('./_baseAssignValue'),\n    createAggregator = require('./_createAggregator');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nmodule.exports = groupBy;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var baseIteratee = require('./_baseIteratee'),\n    isArrayLike = require('./isArrayLike'),\n    keys = require('./keys');\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nmodule.exports = createFind;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n","var createFind = require('./_createFind'),\n    findIndex = require('./findIndex');\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nmodule.exports = find;\n"],"sourceRoot":""}